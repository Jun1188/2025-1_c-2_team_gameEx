화면을 지우는 함수: <windows.h>의 system("cls")
프로그램 실행을 지연시키는 함수: <windows.h>의 Sleep(시간);

일정 시간동안만 입력을 감지하고 못 받으면 다음으로 넘어가는 함수: <conio.h>의 _kbhit()


랜덤한 수를 받는 방법:
<random> 헤더 추가
std::random_device 객체명1;
std::default_random_engine 객체명2(객체명1());
std::uniform_int_distribution<int> 객체명3(최소 난수 범위, 최대 난수 범위);

이후 난수 사용 시에 int num = 객체명3(객체명2);와 같이 하면 num에 난수가 들어간다.

혹은 rand와 srand를 사용해도 된다


using namespace std;를 쓰면 std::는 쓰지 않아도 된다.

std::cin >> 변수 이름 >> 변수 이름2;
: 입력 함수

std::cout << 변수 이름1 << 변수 이름2;
 : 출력 함수

std::string : 문자열 자료형

char 문자 자료형

궁금한 점이나 문제에 오류가 있으면 톡방에 질문해주세요



문제 1개를 선택


1. 복습 및 배열 공부를 위한 바둑알 예측 게임

두 선수가 30*30의 바둑판에서 예측 경쟁을 한다. (바둑판은 바둑알을 놓을 때마다 갱신되며 바둑판의 상태는 업데이트된다)

한 차례에, 두 선수는 각자 한번씩 바둑판에 돌을 놓는다. 
단, 첫번째 선수가 바둑알을 놓고 난 뒤 출력되는 바둑판에서, 바둑알 위치를 포함한 랜덤한 위치의 바둑알 5개가 나타난다.
두번째 선수는 5개의 바둑알 중 첫번째 선수의 바둑알을 예측해 놓는다.

차례가 끝나고 두 선수가 놓은 바둑알의 위치를 확인한다. 바둑알의 위치가 겹치면 두번째 선수가 1점을 가져가고 아니면 첫번째 선수가 1점을 가져간다.
이를 반복한다. 차례가 반복될 때 콘솔창에 바둑판은 계속 하나만 출력되어야 하며, 이전 판에 놓거나 랜덤하게 생성되었던 바둑알이 바둑판에 남아있다.
이전 판에 놓은 바둑알들의 위치에는 다시 놓을 수 없고, 랜덤하게 생성되었던 바둑알의 위치에도 놓을 수 없다. 랜덤 생성 바둑알도 마찬가지다.

매 차례마다 두 선수의 바둑알의 표기는 달라져야 한다.

바둑판이 가득 차면 게임이 끝나고 승자를 출력한다.




2. 리듬게임

60*30의 공간에서 일자 형태의 세로로 기다란 바(네모 도형)가 랜덤한 열에 랜덤한 길이로 출력된다.
단, 바는 서로 겹쳐선 안되고, 한번에 바 3개 이상, 5개 이하가 공간 안에 있어야 하며, 공간을 넘어서면 바가 사라진다.

사용자는 바가 바닥과 맞닿기 1칸 전~닿은 즉시 해당 열의 좌표를 입력해야 한다.
입력한 열과 해당 바의 열이 같으면 1점을 얻는다.

화면은 5초 동안 유지되다가 출력된지 5초를 넘으면 갱신되며, 갱신될 때마다 바는 1칸씩 밑으로 내려와야 한다.

점수가 7점을 넘기면 승리한다. 시작한지 120초가 넘으면 게임이 끝나고 패배한다.

바의 한칸에 해당하는 부분의 출력 문자는 자유롭게 정한다.

